/*
 * Copyright (C) 2002-2023 CERN for the benefit of the ATLAS collaboration.
 */
/**
 * @file UnwindBacktrace.cc
 * @author scott snyder <snyder@bnl.gov>
 * @date Feb, 2021
 * @brief Hacked backtrace that can go past a bad stack frame.
 */


#include "CxxUtils/UnwindBacktrace.h"


#ifdef HAVE_LINUX_UNWIND_BACKTRACE


#include "CxxUtils/checker_macros.h"
#include <atomic>
#include <unwind.h>
#include <stdio.h>
#include <malloc.h>


// A couple declarations from libgcc that are not in unwind.h.
extern "C" {
  const void* _Unwind_Find_FDE (void*, void*);
  void __register_frame_info (const void*, void*);
  void __deregister_frame_info (const void*);
}


namespace CxxUtils {


typedef          int  sword __attribute__ ((mode (SI)));
typedef unsigned int  uword __attribute__ ((mode (SI)));
using ubyte = unsigned char;


// Some DWARF definitions that we need.
enum
  {
   DW_EH_PE_absptr = 0x00
  };

// Stack unwinder instruction opcodes (see DWARF docs).
enum
  {
    DW_CFA_advance_loc = 0x40,
    DW_CFA_offset = 0x80,
    DW_CFA_restore = 0xc0,
    DW_CFA_extended = 0,

    DW_CFA_nop = 0x00,
    DW_CFA_set_loc = 0x01,
    DW_CFA_advance_loc1 = 0x02,
    DW_CFA_advance_loc2 = 0x03,
    DW_CFA_advance_loc4 = 0x04,
    DW_CFA_offset_extended = 0x05,
    DW_CFA_restore_extended = 0x06,
    DW_CFA_undefined = 0x07,
    DW_CFA_same_value = 0x08,
    DW_CFA_register = 0x09,
    DW_CFA_remember_state = 0x0a,
    DW_CFA_restore_state = 0x0b,
    DW_CFA_def_cfa = 0x0c,
    DW_CFA_def_cfa_register = 0x0d,

    DW_CFA_def_cfa_offset = 0x0e,
    DW_CFA_def_cfa_expression = 0x0f,
    DW_CFA_expression = 0x10,
    DW_CFA_offset_extended_sf = 0x11,
    DW_CFA_def_cfa_sf = 0x12,
    DW_CFA_def_cfa_offset_sf = 0x13,
    DW_CFA_val_offset = 0x14,
    DW_CFA_val_offset_sf = 0x15,
    DW_CFA_val_expression = 0x16,

    DW_CFA_low_user = 0x1c,
    DW_CFA_MIPS_advance_loc8 = 0x1d,
    DW_CFA_GNU_window_save = 0x2d,
    DW_CFA_GNU_args_size = 0x2e,
    DW_CFA_GNU_negative_offset_extended = 0x2f,
    DW_CFA_high_user = 0x3f
  };


// DWARF codes for x86_64 registers (see the ABI doc).
enum Registers
{
  REG_RAX =  0,
  REG_RDX =  1,
  REG_RCX =  2,
  REG_RBX =  3,
  REG_RSI =  4,
  REG_RDI =  5,
  REG_RBP =  6,
  REG_RSP =  7,
  REG_R8  =  8,
  REG_R9  =  9,
  REG_R10 = 10,
  REG_R11 = 11,
  REG_R12 = 12,
  REG_R13 = 13,
  REG_R14 = 14,
  REG_R15 = 15,
  REG_RA  = 16   // return address pseudo-register
};


/// Synthetic dummy CIE structure we inject.
/// Mostly filled in here, except for the length.
struct SynthCIE
{
  uword length;
  sword CIE_id = 0;
  ubyte version = 4;
  unsigned char augmentation[1] = {0};
  ubyte address_size = sizeof(void*);
  ubyte segment_size = 0;
  ubyte code_alignment_factor = 1;
  ubyte data_alignment_factor = 0x78; // -8 in LEB128 encoding
  ubyte return_address_register = REG_RA;
  // Stack unwinding instructions.
  // This is the default unwinding prolog generated by gas on x86_64,
  // describing the state of things at the start of a function.
  // We use this since we're assuming that we've called to bad code
  // and crashed promptly.
  // The CFA is RSP+8, and the RA is then -8(CFA) (eg, (SP)).
  // We get -8 because the 1 below is multiplied by data_alignment_factor.
  ubyte insns[9] = {DW_CFA_def_cfa, REG_RSP, 8,
                    DW_CFA_offset + REG_RA, 1,
                    DW_CFA_nop,DW_CFA_nop,DW_CFA_nop,DW_CFA_nop};
} __attribute__ ((packed, aligned (__alignof__ (void *))));

/// Synthetic FDE structure we inject.
struct SynthFDE
{
  uword length;
  sword CIE_delta;
  void* pc_begin;
  uintptr_t pc_range;
  //ubyte insns[8] = {DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop};
} __attribute__ ((packed, aligned (__alignof__ (void *))));

/// FDE vector structure, used internally by libgcc to hold sorted FDEs.
struct SynthFDEVector
{
  const void* orig_data = nullptr;
  size_t count = 0;
  const struct SynthFDE* array[1] = {nullptr};
};

/// Object structure, used internally by libgcc.
struct SynthObject
{
  void* pc_begin;
  void* tbase;
  void* dbase;
  union {
    const SynthFDE* single;
    SynthFDEVector* sort;
  } u;
  struct {
    unsigned long sorted : 1;
    unsigned long from_aray : 1;
    unsigned long mixed_encoding : 1;
    unsigned long encoding : 8;
    unsigned long count : 21;
  } b;
  struct object* next;
  void* pad;
} __attribute__ ((packed, aligned (__alignof__ (void *))));

/// All the synthetic data we inject.
/// The FDE vector should be allocated with malloc, in case libgcc
/// ever tries to deregister what we give it.  Do that during initialization,
/// so that we're not trying to allocate memory after a crash.
struct SynthData
{
  SynthCIE cie;
  SynthFDE fde;
  uword sentinel;
  uword padding;
  SynthObject ob;
  SynthFDEVector* vec;
  SynthData() : vec (reinterpret_cast<SynthFDEVector*>(malloc (sizeof (SynthFDEVector)))) {}
  ~SynthData() { if (vec) free (vec); }
  SynthData (const SynthData&) = delete;
  SynthData& operator= (const SynthData&) = delete;
} __attribute__ ((packed, aligned (__alignof__ (void *))));


// Statically-allocated FDE data to inject.
static SynthData synthData ATLAS_THREAD_SAFE;


/**
 * @brief Try to fix up stack trace for bad frame with IP ADDR.
 * @param addr The IP of the bad frame.
 *
 * We get here if we've hit a bad stack frame (for which we can't find
 * a FDE).  ADDR is the IP for which we tried to find the FDE.
 * Try to make a synthetic dummy FDE describing this address and
 * register it with gcc.  Only do this once, however.  Return true
 * if we did a fixup, false if we didn't (because we already did one).
 */
bool tryUnwindFixup (_Unwind_Ptr addr)
{
  // Only allow going past this point once.
  static std::atomic<int> fixed = 0;
  int exp = 0;
  if (!fixed.compare_exchange_strong (exp, 1)) {
    return false;
  }

  // Initialize synthetic CIE/FDE data.
  SynthData& data = synthData;
  data.cie.length = sizeof (data.cie) - sizeof (data.cie.length);
  data.fde.length = sizeof (data.fde) - sizeof (data.fde.length);
  // cppcheck-suppress comparePointers
  data.fde.CIE_delta = reinterpret_cast<char*>(&data.fde.CIE_delta) - reinterpret_cast<char*>(&data.cie.length);
  data.fde.pc_begin = (void*)addr;
  data.fde.pc_range = 8;
  data.sentinel = 0;

  // Register it with libgcc.
  __register_frame_info (&data.fde, &data.ob);

  // The first time we try to use the new FDE, libgcc will try to allocate
  // memory for the sorted FDE vector.  But we want to avoid allocating memory
  // here.  We can do this by diddling the internal libgcc structure to point
  // to a pre-allocated vector object.  But this is inherently racy: we
  // should be holding the libgcc lock when doing this, but that's not exported
  // from the library.  We make do by initializing the fields in an order
  // that should be safe (enforced by memory fences) and hope for the best.
  std::atomic_thread_fence (std::memory_order_seq_cst);
  data.vec->orig_data = &data.fde;
  data.vec->count = 1;
  data.vec->array[0] = &data.fde;
  std::atomic_thread_fence (std::memory_order_seq_cst);
  data.ob.u.sort = data.vec;
  data.vec = nullptr;
  data.ob.b.encoding = DW_EH_PE_absptr;
  data.ob.pc_begin = data.fde.pc_begin;
  data.ob.b.count = 1;
  std::atomic_thread_fence (std::memory_order_seq_cst);
  data.ob.b.sorted = 1;

  return true;
}


//************************************************************************


/// Needed as an argument to _Unwind_Find_FDE.
struct dwarf_eh_bases
{
  void *tbase;
  void *dbase;
  void *func;
};


/// Accumulate data during a backtrace.
struct UnwindBacktraceData
{
  static constexpr unsigned MAX_DEPTH = 128;
  unsigned naddr = 0;
  _Unwind_Ptr addrs[MAX_DEPTH] = {0};
  bool sawBad = false;
};


/**
 * @brief Backtrace callback.
 * Called by the libgcc framework for each stack frame.
 * Record the return addresses in UnwindBacktraceData.
 * If we hit a bad stack frame, set a flag and abort.
 */
_Unwind_Reason_Code
unwindBacktraceCallback (_Unwind_Context *ctx, void *data_in)
{
  // Record this IP.
  auto& data = *reinterpret_cast<UnwindBacktraceData*> (data_in);
  _Unwind_Ptr ip = _Unwind_GetIP (ctx);
  data.addrs[data.naddr++] = ip;

  if (ip == 0 && !data.sawBad) {
    // Is this the end of the stack, or a bad frame?  Try to guess.
    _Unwind_Word cfa = _Unwind_GetCFA (ctx);
    if (cfa) {
      void* x = *reinterpret_cast<void**>(cfa);
      if (x) {
        dwarf_eh_bases bases;
        if (_Unwind_Find_FDE (x, &bases) != nullptr) {
          data.sawBad = false;
          return _URC_END_OF_STACK;
        }
      }
    }
  }
  else {
    // If we can't find the FDE for this address, set a flag and abort.
    dwarf_eh_bases bases;
    if (!data.sawBad && _Unwind_Find_FDE (reinterpret_cast<void*>(ip), &bases) == nullptr)
    {
      data.sawBad = true;
      return _URC_END_OF_STACK;
    }
  }

  // Stop if we've hit the end of our buffer.
  if (data.naddr == UnwindBacktraceData::MAX_DEPTH)
    return _URC_END_OF_STACK;

  return _URC_NO_REASON;
}


/**
 * @brief Generate a backtrace using _UnwindBacktrace,
 *        trying to handle a possible bad stack frame.
 * @param lineFn Function to call for each line.
 * @param fd File descriptor for output.
 */
void backtraceByUnwind (backtraceLineFn* lineFn, IOFD fd)
{
  // Do the backtrace once.
  UnwindBacktraceData data;
  _Unwind_Backtrace (unwindBacktraceCallback, &data);

  // If we saw a bad entry, then try to fix it up.
  // If that worked, retry the backtrace.
  if (data.sawBad && tryUnwindFixup (data.addrs[data.naddr-1])) {
    data.naddr = 0;
    _Unwind_Backtrace (unwindBacktraceCallback, &data);
  }

  // Clean a null entry from the end of the list.
  if (data.naddr > 0 && data.addrs[data.naddr-1] == 0) {
    --data.naddr;
  }

  for (unsigned i = 0; i < data.naddr; i++) {
    lineFn (fd, data.addrs[i]);
  }
}


} // namespace CxxUtils


namespace {


// Make sure there's a block on the free list of the internal btree
// libgcc uses to keep track of registrations, so we won't have
// to call malloc later.
bool initUnwind()
{
  CxxUtils::SynthData data;
  data.cie.length = sizeof (data.cie) - sizeof (data.cie.length);
  data.fde.length = sizeof (data.fde) - sizeof (data.fde.length);
  // cppcheck-suppress comparePointers
  data.fde.CIE_delta = reinterpret_cast<char*>(&data.fde.CIE_delta) - reinterpret_cast<char*>(&data.cie.length);
  data.fde.pc_begin = (void*)&data;
  data.fde.pc_range = 8;
  data.sentinel = 0;

  __register_frame_info (&data.fde, &data.ob);
  __deregister_frame_info (&data.fde);
  return true;
}
const static bool initUnwindFlag = initUnwind();


} // anonymous namespace


#endif
