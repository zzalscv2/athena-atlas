# Copyright (C) 2002-2023 CERN for the benefit of the ATLAS collaboration

from GaudiConfig2.semantics import getSemanticsFor, SequenceSemantics
from AthenaCommon.Logging import logging

class OutputStreamItemListSemantics(SequenceSemantics):
    __handled_types__ = ( "OutputStreamItemList", )

    def __init__(self, cpp_type, name=None):
        valueSem = getSemanticsFor("std::string") if cpp_type in self.__handled_types__ else None
        super(OutputStreamItemListSemantics, self).__init__(cpp_type, name, valueSem=valueSem)

    def merge(self, bb, aa):
        msg = logging.getLogger("OutputStreamItemListMerge")
        msg.info("CA: Merging ItemList properties")
        for b in bb:
            if b not in aa:
                aa.append(b)
        if aa.is_dirty:
            msg.info("CA: Merging Aux attributes in the ItemList")
            scrubbed = self.checkAuxAttributes( aa )
            aa._data = []
            aa.extend( scrubbed )
            aa.isDirty = False
            aa.default = aa._data  # if 'dirty' flag not set then "default" is returned instead of "data"
        return aa

    def checkAuxAttributes(self, itemList):
        """
        Checks dynamic Aux attribute selection in the ItemList for duplicates and conflicts

        From Event/xAOD/xAODCore/Root/AuxSelection.cxx
        The formalism for attribute selection is the following:
         - An empty set, or a set containing "*" will select all the dynamic
             attributes passed to the object.
         - A single "-" attribute will not select any of the dynamic attributes.
         - A set of variables (without "-" as the first character of the
             variable names) will select just the variables listed.
         - A set of variable names, each prefixed by "-", will select all
             variables but the ones listed.
        """
        msg = logging.getLogger("OutputStreamItemListAuxCheck")
        AUX = "Aux."
        newitemlist=[]
        from collections import defaultdict
        auxitems = defaultdict(set)
        for item in itemList:
            auxpos = item.find(AUX)
            if auxpos > 0:
                # Aux store item
                itemname = item[ : auxpos+len(AUX)]
                selection = item[auxpos+len(AUX) : ]
                # collect attributes selection for this item in a set
                # empty selection means 'everything'
                auxitems[itemname].add( selection )
            else:
                newitemlist.append(item)

        newauxlist=[]
        for k,sel in auxitems.items():
            allsel = set()    # gather all selection items in this set
            for line in sel:
                allsel.update( line.split('.') )
                if ".." in line or line.startswith(".") or line.endswith('.'):
                    msg.warning("Extra dot in Aux attribute selection - check the configuration for possible mistakes: " +
                                f"{k} {str(sel)}")
                    # remove empty element generated by the extra dots
                    allsel.remove('')
            negsel = [s for s in allsel if s[:1]=='-']
            if negsel and len(negsel) != len(allsel):
                raise ValueError(f"Mixing up negative and positive Aux selections is not supported: {k} : {str(sel)}")
            if len(sel) == 1:
                # single selection, just pass it on
                newauxlist.append( k + "".join(sel) )
                continue
            # multiple selections fun
            if negsel:
                # multiple different negative selections are usually logically incompatible, report error
                raise ValueError(f"Multiiple (different) negative selection are not supported: for {k} : {str(sel)}")
            if '' in sel or '*' in sel:
                msg.info(f"Multiple Aux attribute selections for {k} - will write all attributes." +
                         f" Original selection was: {str(sel)}")
                newauxlist.append( k + '*')
                continue
            # 2 or more positive selections - merge them into one
            newitem =  k + ".".join(allsel)
            newauxlist.append(newitem)
            msg.info(f"Multiple attribute selections for {k} - will write combined selection. Found {len(sel)} items: {str(sel)}")
            msg.info(f"  New selection: {newitem}")

        return newitemlist + newauxlist
