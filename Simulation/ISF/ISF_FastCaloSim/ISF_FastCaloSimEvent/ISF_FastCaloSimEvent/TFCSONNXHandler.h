/**
 * Copyright (C) 2002-2023 CERN for the benefit of the ATLAS collaboration
 *
 * Class for a neural network read in the ONNX format.
 * Derived from the abstract base class VNetworkBase
 * such that it can be used interchangably with it's
 * sibling classes, TFCSSimpleLWTNNHandler and TFCSGANLWTNNHandler.
 *
 * The TFCSNetworkFactory::Create function has VNetworkBase as its return
 * type so that it can make a run-time decision about which derived
 * class to use, based on the data or file presented. As such it's
 * best not to create this directly, instead allow TFCSNetworkFactory::Create
 * to create the appropreat network object so that new network formats can
 * be accomidated by writing new subclasses of VNetworkBase.
 **/

#ifndef TFCSONNXHANDLER_H
#define TFCSONNXHANDLER_H

// inherits from
#include "ISF_FastCaloSimEvent/VNetworkBase.h"

#include <iostream>

// ONNX Runtime include(s).
#include <core/session/onnxruntime_cxx_api.h>

// For reading and writing to root
#include "TFile.h"
#include "TTree.h"

// For storing the lambda function
#include <functional>

/**
 * @brief A handler specific for an ONNX network
 *
 * Inherits from the generic interface VNetworkBase,
 * such that it cna be used interchangably with other network
 * formats and libraries.
 **/
class TFCSONNXHandler : public VNetworkBase {
public:
  // Don't lose the default constructor
  using VNetworkBase::VNetworkBase;

  /**
   * @brief TFCSONNXHandler constructor.
   *
   * Calls setupPersistedVariables and setupNet.
   *
   * @param inputFile file-path on disk (with file name) of a readable
   *                  onnx file containing a proto format description
   *                  of the network to be constructed.
   **/
  explicit TFCSONNXHandler(const std::string &inputFile);

  /**
   * @brief TFCSONNXHandler constructor.
   *
   * As this passes nothing to the super constructor
   * the setupPersistedVariables will not be called.
   *
   * @param bytes    byte content of a .onnx file, (which are a subset
   *                 if proto files). Allows TFCSONNXHandler objects to be
   *                 created from data in memory, retrived rom any source.
   *                 The bytes are not copied interally, and must remain
   *                 in memory while the net is in use.
   *                 (TODO check that assertion)
   *
   **/
  explicit TFCSONNXHandler(const std::vector<char> &bytes);

  /**
   * @brief TFCSONNXHandler copy constructor.
   *
   * Will copy the variables taht would be generated by
   * setupPersistedVariables and setupNet.
   *
   * @param copy_from existing network that we are copying
   **/
  TFCSONNXHandler(const TFCSONNXHandler &copy_from);

  /**
   * @brief Function to pass values to the network.
   *
   * This function is used to actually run data through the loaded
   * network and obtain results.
   *
   * @param inputs  values to be evaluated by the network
   * @return        the output of the network
   * @see VNetworkBase::NetworkInputs
   * @see VNetworkBase::NetworkOutputs
   **/
  NetworkOutputs compute(NetworkInputs const &inputs) const override;

  // Output to a ttree file
  using VNetworkBase::writeNetToTTree;

  /**
   * @brief Save the network to a TTree.
   *
   * All data required to recreate the network object is saved
   * into a TTree. The format is not specified.
   * Will still work even if deleteAllButNet has already
   * been called.
   *
   * @param tree  The tree to save inside.
   **/
  void writeNetToTTree(TTree &tree) override;

  /**
   * @brief List the names of the outputs.
   *
   * Outputs are stored in an NetworkOutputs object
   * which is indexed by strings. This function
   * returns the list of all strings that will index the outputs.
   *
   **/
  std::vector<std::string> getOutputLayers() const override;

  /**
   * @brief Get rid of any memory objects that arn't needed to run the net.
   *
   * Minimise memory usage by deleting nay inputs that are
   * no longer required to run the compute function.
   * Doesn't actually do anything for this network type.
   *
   **/
  void deleteAllButNet() override;

protected:
  /**
   * @brief Write a short description of this net to the string stream.
   *
   * Specialised for ONNX to print the input and output nodes with their
   * dimensions.
   *
   * @param strm  output parameter, to which the description will be written.
   **/
  virtual void print(std::ostream &strm) const override;

  /**
   * @brief Perform actions that prep data to create the net
   *
   * Will be called in the class constructor
   * before calling setupNet, but not in the streamer.
   * It sets any variables that the sreamer would persist
   * when saving or loading to file.
   *
   **/
  void setupPersistedVariables() override;

  /**
   * @brief Perform actions that prepare network for use.
   *
   * Will be called in the streamer or class constructor
   * after the inputs have been set (either automaically by the
   * streamer or by setupPersistedVariables in the constructor).
   * Does not delete any resources used.
   *
   **/
  void setupNet() override;

private:
  /**
   * @brief Content of the proto file.
   **/
  std::vector<char> m_bytes;
  /**
   * @brief Return content of the proto (.onnx) file in memory.
   *
   * Get the session as a stream of bytes
   * It's a vector<char> rather than a string becuase we need the guarantee
   * that &bytes[0]+n == bytes[n] (string has this only after c++11).
   * Also bytes may not be terminated by a null byte
   * (which early strings required).
   *
   **/
  std::vector<char>
  getSerializedSession(std::string tree_name = m_defaultTreeName);
  /**
   * @brief Retrieve the content of the proto file from a TTree
   *
   * If the ONNX file has been saved as a loose variable in a TTree
   * this method will read it back into m_bytes.
   *
   **/
  std::vector<char> readBytesFromTTree(TTree &tree);
  /**
   * @brief Write the content of the proto file to a TTree as a branch
   *
   * The ONNX proto file is saved as a simple branch (no streamers involved).
   *
   **/
  void writeBytesToTTree(TTree &tree, const std::vector<char> &bytes);

  // unique ptr deletes the object when it goes out of scope
  /**
   * @brief The network session itself
   *
   * This is the object created by onnxruntime_cxx_api which
   * contains information about the network and can run inputs
   * through it.
   *
   * Held as a unique pointer to prevent the need for manual
   * memory management
   **/
  std::unique_ptr<Ort::Session> m_session; //! Do not persistify
  /**
   * @brief Using content of the proto (.onnx) file make a session.
   *
   * The m_session variable is initialised from the m_bytes variable
   * so that the net can be run.
   * Requires that the m_bytes variable is retained while the net is
   * used.
   *
   **/
  void readSerializedSession();

  /**
   * @brief names that index the input nodes
   *
   * An ONNX network is capable of having two layers of
   * labels, input node names, then labels within each node,
   * but it's twin, LWTNN is not. LWTNN supports one list of
   * nodes indexed by strings, and each input node may have
   * more than one value, indexed by positive integers (list
   * like), so this interfae only supports that more limited
   * format.
   *
   **/
  std::vector<const char *> m_inputNodeNames; //! Do not persistify

  /**
   * @brief the names that index the output nodes
   *
   * An ONNX network is capable of having two layers of
   * labels, input node names, then labels within each node,
   * but it's twin, LWTNN is not. LWTNN supports one list of
   * nodes indexed by strings, and each input node may have
   * more than one value, indexed by positive integers (list
   * like), so this interfae only supports that more limited
   * format.
   *
   **/
  std::vector<const char *> m_outputNodeNames; //! Do not persistify

  /**
   * @brief dimension lengths in each named input node
   *
   * Describes the shape of the input nodes.
   * @see TFCSONNXHandler::m_inputNodeNames
   **/
  std::vector<std::vector<int64_t>> m_inputNodeDims; //! Do not persistify
  /**
   * @brief dimension lengths in each named output node
   *
   * As the final output must be flat in each output node,
   * this is for internal manipulations only.
   * @see TFCSONNXHandler::m_inputNodeDims
   **/
  std::vector<std::vector<int64_t>> m_outputNodeDims; //! Do not persistify
  /**
   * @brief total elements in each named output node
   *
   * For internal use only, gives the total number of elements in
   * the output nodes.
   * @see TFCSONNXHandler::m_inputNodeDims
   **/
  std::vector<int64_t> m_outputNodeSize; //! Do not persistify

  /**
   * @brief Computation template with adjustable types for input.
   *
   * A lambda function will be used to make the correct type choice
   * for the session/net used as a member variable during setupNet.
   **/
  template <typename Tin, typename Tout>
  NetworkOutputs computeTemplate(NetworkInputs const &input);

  /**
   * @brief computeTemplate with apropreate types selected.
   **/
  std::function<NetworkOutputs(NetworkInputs)>
      m_computeLambda; //! Do not persistify

  /**
   * @brief Specifies memory behavior for vectors in ONNX.
   **/
  Ort::MemoryInfo m_memoryInfo = Ort::MemoryInfo::CreateCpu(
      OrtArenaAllocator, OrtMemTypeDefault); //! Do not persistify

  /**
   * @brief Externally visible names that index the output.
   **/
  std::vector<std::string> m_outputLayers; //! Do not persistify

  // For the streamer
  ClassDefOverride(TFCSONNXHandler, 1);
};

#endif // TFCSONNXHANDLER_H
