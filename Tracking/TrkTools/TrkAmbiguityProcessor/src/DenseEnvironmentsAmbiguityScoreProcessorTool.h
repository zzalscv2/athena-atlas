/*
  Copyright (C) 2002-2023 CERN for the benefit of the ATLAS collaboration
*/

#ifndef DenseEnvironmentsAmbiguityScoreProcessorTool_H
#define DenseEnvironmentsAmbiguityScoreProcessorTool_H

#include "AthenaBaseComps/AthAlgTool.h"
#include "GaudiKernel/ToolHandle.h"

#include "TrkToolInterfaces/ITrackAmbiguityScoreProcessorTool.h"
#include "TrkEventPrimitives/TrackScore.h"
#include "TrkFitterInterfaces/ITrackFitter.h"
#include "InDetPrepRawData/PixelGangedClusterAmbiguities.h"
#include "TrkValInterfaces/ITrkObserverTool.h"

//need to include the following, since its a typedef and can't be forward declared.
#include "TrkTrack/TrackCollection.h"
#include "TrkTrack/TrackSeedMap.h"
#include "TrkParameters/TrackParameters.h"

#include "TrkToolInterfaces/IPRDtoTrackMapTool.h"
#include "TrkEventUtils/PRDtoTrackMap.h"
#include "InDetRecToolInterfaces/IPixelClusterSplitProbTool.h"
#include "TrkEventUtils/ClusterSplitProbabilityContainer.h"
#include "AmbiCounter.h"
#include <map>
#include <set>
#include <vector>

namespace InDet{
  class PixelCluster;
  class SCT_Cluster;
}

namespace Trk {

  class ITrackScoringTool;

  class DenseEnvironmentsAmbiguityScoreProcessorTool final
      : public AthAlgTool,
        virtual public ITrackAmbiguityScoreProcessorTool {
   public:
    enum class ScoreCategory {
      kNtracks,
      kNcandidates,
      kNcandScoreZero,
      kNcandDouble,
      kNaccept,
      kNCounter
    };
    using Counter = AmbiCounter<ScoreCategory>;
      // public types
      typedef std::multimap< TrackScore, const Track* > TrackScoreMap;
      typedef std::vector<const PrepRawData*> PrdSignature;
      typedef std::set<PrdSignature> PrdSignatureSet;

      // default methods
      DenseEnvironmentsAmbiguityScoreProcessorTool(const std::string&,const std::string&,const IInterface*);
      virtual ~DenseEnvironmentsAmbiguityScoreProcessorTool();
      virtual StatusCode initialize() override final;
      virtual StatusCode finalize  () override final;

      virtual void process(const TrackCollection & tracks, TracksScores* trackScoreTrackMap) const override final;

      /** statistics output to be called by algorithm during finalize. */
      void statistics() override;
      void dumpStat(MsgStream &out) const;
    private:


      /**Add passed TrackCollection, and Trk::PrepRawData from tracks to caches
         @param tracks the TrackCollection is looped over,
         and each Trk::Track is added to the various caches.
         The Trk::PrepRawData from each Trk::Track are added to the IPRD_AssociationTool*/
      void addNewTracks(const TrackCollection & tracks,
                        TracksScores* trackScoreTrackMap) const;

      /**  Find SiS Tracks that share hits in the track score map*/
      void overlappingTracks(const TracksScores* scoreTrackMap,
                             InDet::PixelGangedClusterAmbiguities *splitClusterMap,
                             Trk::ClusterSplitProbabilityContainer &splitProbContainer,
                             Trk::PRDtoTrackMap &prd_to_track_map) const;

      /**  Update pixel split information based using the fitted track*/
      void updatePixelSplitInformationForCluster(const std::pair<const InDet::PixelCluster* const,
                                                                 const Trk::TrackParameters*> & clusterTrkPara,
                                                 InDet::PixelGangedClusterAmbiguities *splitClusterMap,
                                                 Trk::ClusterSplitProbabilityContainer &splitProbContainer) const;


      /**Scoring tool
         This tool is used to 'score' the tracks, i.e. to quantify what a good track is.
         @todo The actual tool that is used should be configured through job options*/
      ToolHandle<ITrackScoringTool> m_scoringTool
	 {this, "ScoringTool", "Trk::TrackScoringTool/TrackScoringTool" };

      ToolHandle<Trk::IPRDtoTrackMapTool>         m_assoTool
         {this, "AssociationTool", "InDet::InDetPRDtoTrackMapToolGangedPixels" };

      ToolHandle<Trk::IPRDtoTrackMapTool>         m_assoToolNotGanged
         {this, "AssociationToolNotGanged", "Trk::PRDtoTrackMapTool" };  // @TODO why are ganged pixels ignored ?

      /** recalculate split prob tool **/
      ToolHandle<InDet::IPixelClusterSplitProbTool> m_splitProbTool
	 {this, "SplitProbTool", "InDet::NnPixelClusterSplitProbTool/NnPixelClusterSplitProbTool" };

      /**Observer tool      This tool is used to observe the tracks and their 'score' */
      PublicToolHandle<Trk::ITrkObserverTool> m_observerTool{this, "ObserverTool", "", "track observer within ambiguity solver"};

      /** cluster split information generated by previous instances*/
      SG::ReadHandleKey<InDet::PixelGangedClusterAmbiguities>  m_splitClusterMapKey_last;

      /** cluster split information which m_splitClusterMap_last will be merged into*/
      SG::WriteHandleKey<InDet::PixelGangedClusterAmbiguities>  m_splitClusterMapKey;

       /** key for the PRDtoTrackMap to be used by the ambiguity process to resolve the ambiguities.**/
      SG::WriteHandleKey<Trk::PRDtoTrackMap>  m_assoMapName
         {this,"AssociationMapName",""};  ///< the key given to the newly created association map

     SG::ReadHandleKey<Trk::ClusterSplitProbabilityContainer>  m_clusterSplitProbContainerIn
         {this,"InputClusterSplitProbabilityName",""};  ///< the key given to the newly created association map
     SG::WriteHandleKey<Trk::ClusterSplitProbabilityContainer>  m_clusterSplitProbContainerOut
         {this,"OutputClusterSplitProbabilityName",""};  ///< the key given to the newly created association map

      /**NN split sprob cut for 2 particle clusters */
      float m_sharedProbCut;

      /**NN split sprob cut for 3 particle clusters */
      float m_sharedProbCut2;

      std::vector<float>     m_etaBounds;           //!< eta intervals for internal monitoring
      mutable std::mutex m_statMutex;
      mutable Counter  m_stat ATLAS_THREAD_SAFE;
  };
} //end ns


#endif // TrackAmbiguityProcessorTool_H
